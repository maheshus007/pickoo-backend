name: Deploy to AWS Elastic Beanstalk

on:
  push:
    branches:
      - main
      - develop
      - production
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  AWS_REGION: ap-south-1
  EB_APPLICATION_NAME: pickoo-backend
  EB_ENVIRONMENT_NAME_PROD: pickoo-backend-env
  EB_ENVIRONMENT_NAME_STAGING: pickoo-backend-env

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-asyncio httpx

    - name: Run linting
      run: |
        pip install flake8
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
      continue-on-error: true

    - name: Run tests
      env:
        PYTHONPATH: ${{ github.workspace }}
      run: |
        export PYTHONPATH="${PYTHONPATH}:."
        pytest tests/ -v --cov=. --cov-report=xml --cov-report=html
      continue-on-error: true

    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: htmlcov/
        retention-days: 7

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Set environment name
      id: set-env
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
          echo "env_name=${{ env.EB_ENVIRONMENT_NAME_STAGING }}" >> $GITHUB_OUTPUT
        else
          echo "env_name=${{ env.EB_ENVIRONMENT_NAME_PROD }}" >> $GITHUB_OUTPUT
        fi

    - name: Create .env file
      run: |
        cat <<EOF > .env
        PICKOO_PROCESSOR_MODE=${{ secrets.PROCESSOR_MODE || 'existing' }}
        PICKOO_GEMINI_BASE_URL=${{ secrets.GEMINI_BASE_URL || 'https://generativelanguage.googleapis.com/' }}
        PICKOO_GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
        PICKOO_GEMINI_MODEL=${{ secrets.GEMINI_MODEL || 'gemini-2.0-flash-exp' }}
        PICKOO_MONGO_URI=${{ secrets.MONGO_URI }}
        PICKOO_JWT_SECRET=${{ secrets.JWT_SECRET }}
        PICKOO_JWT_EXP_MINUTES=${{ secrets.JWT_EXP_MINUTES || '60' }}
        PICKOO_STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
        PICKOO_STRIPE_PUBLISHABLE_KEY=${{ secrets.STRIPE_PUBLISHABLE_KEY }}
        PICKOO_STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }}
        EOF

    - name: Create Procfile for Elastic Beanstalk
      run: |
        cat <<EOF > Procfile
        web: uvicorn main:application --host 0.0.0.0 --port 8000 --workers 2
        EOF

    - name: Create .ebextensions configuration
      run: |
        mkdir -p .ebextensions
        cat <<EOF > .ebextensions/01_packages.config
        packages:
          yum:
            git: []
            gcc: []
            python3-devel: []
            libjpeg-devel: []
            zlib-devel: []
        EOF
        
        cat <<EOF > .ebextensions/02_python.config
        option_settings:
          aws:elasticbeanstalk:application:environment:
            PYTHONPATH: "/var/app/current:\$PYTHONPATH"
          aws:elasticbeanstalk:container:python:
            WSGIPath: main:application
        EOF
        
        cat <<EOF > .ebextensions/03_health_check.config
        option_settings:
          aws:elasticbeanstalk:environment:process:default:
            HealthCheckPath: /health
            HealthCheckInterval: 30
            HealthCheckTimeout: 5
            UnhealthyThresholdCount: 3
            HealthyThresholdCount: 3
        EOF

    - name: Create application version timestamp
      id: timestamp
      run: echo "timestamp=$(date +%Y%m%d_%H%M%S)" >> $GITHUB_OUTPUT

    - name: Create deployment package
      run: |
        zip -r deploy-${{ steps.timestamp.outputs.timestamp }}.zip . \
          -x "*.git*" \
          -x "*__pycache__*" \
          -x "*.pytest_cache*" \
          -x "*.venv*" \
          -x "*venv*" \
          -x "*.env" \
          -x "*htmlcov*" \
          -x "*.coverage*" \
          -x "*tests*"

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify AWS credentials
      run: |
        echo "Verifying AWS credentials..."
        aws sts get-caller-identity
        echo "‚úÖ AWS credentials valid"

    - name: Verify EB_S3_BUCKET secret is set
      run: |
        if [ -z "${{ secrets.EB_S3_BUCKET }}" ]; then
          echo "‚ùå ERROR: EB_S3_BUCKET secret is NOT set!"
          echo "Please add EB_S3_BUCKET secret in:"
          echo "https://github.com/${{ github.repository }}/settings/secrets/actions"
          echo ""
          echo "Example value: pickoo-backend-deployments"
          exit 1
        fi
        echo "‚úÖ EB_S3_BUCKET secret is set"
        echo "Note: Actual bucket name is hidden in logs for security"

    - name: Ensure S3 bucket exists
      run: |
        BUCKET_NAME="${{ secrets.EB_S3_BUCKET }}"
        
        if [ -z "$BUCKET_NAME" ]; then
          echo "‚ùå Error: EB_S3_BUCKET secret is not set!"
          echo "Please add EB_S3_BUCKET secret in GitHub repository settings"
          exit 1
        fi
        
        echo "Checking S3 bucket: $BUCKET_NAME"
        
        if aws s3 ls "s3://${BUCKET_NAME}" 2>&1 | grep -q 'NoSuchBucket'; then
          echo "Creating S3 bucket: $BUCKET_NAME"
          aws s3 mb "s3://${BUCKET_NAME}" --region ${{ env.AWS_REGION }}
          echo "‚úÖ S3 bucket created"
        else
          echo "‚úÖ S3 bucket exists"
        fi

    - name: Upload to S3
      run: |
        BUCKET_NAME="${{ secrets.EB_S3_BUCKET }}"
        S3_KEY="pickoo-backend/deploy-${{ steps.timestamp.outputs.timestamp }}.zip"
        
        echo "Uploading to S3..."
        echo "Bucket: $BUCKET_NAME"
        echo "Key: $S3_KEY"
        echo "Timestamp: ${{ steps.timestamp.outputs.timestamp }}"
        
        aws s3 cp deploy-${{ steps.timestamp.outputs.timestamp }}.zip \
          "s3://${BUCKET_NAME}/${S3_KEY}" \
          --region ${{ env.AWS_REGION }} \
          --acl bucket-owner-full-control
        
        echo "‚úÖ Upload successful"

    - name: Set S3 bucket policy for Elastic Beanstalk access
      run: |
        BUCKET_NAME="${{ secrets.EB_S3_BUCKET }}"
        
        echo "Setting bucket policy to allow Elastic Beanstalk access..."
        
        cat > bucket-policy.json <<EOF
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Sid": "AllowElasticBeanstalkAccess",
              "Effect": "Allow",
              "Principal": {
                "Service": "elasticbeanstalk.amazonaws.com"
              },
              "Action": [
                "s3:GetObject",
                "s3:GetObjectVersion",
                "s3:ListBucket"
              ],
              "Resource": [
                "arn:aws:s3:::${BUCKET_NAME}/*",
                "arn:aws:s3:::${BUCKET_NAME}"
              ]
            }
          ]
        }
        EOF
        
        aws s3api put-bucket-policy \
          --bucket "${BUCKET_NAME}" \
          --policy file://bucket-policy.json
        
        echo "‚úÖ Bucket policy updated"

    - name: Debug S3 bucket location
      run: |
        BUCKET_NAME="${{ secrets.EB_S3_BUCKET }}"
        echo "Getting bucket location..."
        aws s3api get-bucket-location --bucket "$BUCKET_NAME" --output json || echo "Failed to get bucket location"

    - name: Debug S3 object metadata
      run: |
        BUCKET_NAME="${{ secrets.EB_S3_BUCKET }}"
        S3_KEY="pickoo-backend/deploy-${{ steps.timestamp.outputs.timestamp }}.zip"
        
        echo "Getting object metadata..."
        echo "Bucket: $BUCKET_NAME"
        echo "Key: $S3_KEY"
        
        aws s3api head-object \
          --bucket "$BUCKET_NAME" \
          --key "$S3_KEY" \
          --output json || echo "Failed to get object metadata"

    - name: Debug S3 object ACL
      run: |
        BUCKET_NAME="${{ secrets.EB_S3_BUCKET }}"
        S3_KEY="pickoo-backend/deploy-${{ steps.timestamp.outputs.timestamp }}.zip"
        
        echo "Getting object ACL..."
        aws s3api get-object-acl \
          --bucket "$BUCKET_NAME" \
          --key "$S3_KEY" \
          --output json || echo "Failed to get object ACL"

    - name: Verify S3 object exists
      run: |
        BUCKET_NAME="${{ secrets.EB_S3_BUCKET }}"
        S3_KEY="pickoo-backend/deploy-${{ steps.timestamp.outputs.timestamp }}.zip"
        
        echo "Verifying S3 file..."
        echo "Full S3 path: s3://${BUCKET_NAME}/${S3_KEY}"
        
        aws s3 ls "s3://${BUCKET_NAME}/${S3_KEY}"
        echo "‚úÖ S3 file verified"

    - name: Check if Elastic Beanstalk application exists
      id: check-app
      run: |
        echo "Checking if application exists..."
        if aws elasticbeanstalk describe-applications --application-names ${{ env.EB_APPLICATION_NAME }} 2>&1 | grep -q "ApplicationName"; then
          echo "‚úÖ Application exists"
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "‚ö†Ô∏è Application does not exist, will create"
          echo "exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Create Elastic Beanstalk application if not exists
      if: steps.check-app.outputs.exists == 'false'
      run: |
        echo "Creating EB application: ${{ env.EB_APPLICATION_NAME }}"
        aws elasticbeanstalk create-application \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --description "Pickoo AI Photo Editor Backend API"
        echo "‚úÖ Application created successfully"

    - name: Verify S3 file exists
      run: |
        BUCKET_NAME="${{ secrets.EB_S3_BUCKET }}"
        S3_KEY="pickoo-backend/deploy-${{ steps.timestamp.outputs.timestamp }}.zip"
        
        echo "Verifying S3 file..."
        aws s3 ls "s3://${BUCKET_NAME}/${S3_KEY}" --region ${{ env.AWS_REGION }}
        echo "‚úÖ S3 file verified"

    - name: Create Elastic Beanstalk application version
      run: |
        BUCKET_NAME="${{ secrets.EB_S3_BUCKET }}"
        S3_KEY="pickoo-backend/deploy-${{ steps.timestamp.outputs.timestamp }}.zip"
        VERSION_LABEL="v-${{ steps.timestamp.outputs.timestamp }}-${{ github.run_number }}"
        
        echo "Creating application version: $VERSION_LABEL"
        echo "Application: ${{ env.EB_APPLICATION_NAME }}"
        echo "S3 Bucket: $BUCKET_NAME (masked for security)"
        echo "S3 Bucket length: ${#BUCKET_NAME}"
        echo "S3 Key: $S3_KEY"
        echo "Region: ${{ env.AWS_REGION }}"
        echo "Timestamp: ${{ steps.timestamp.outputs.timestamp }}"
        
        if [ -z "$BUCKET_NAME" ]; then
          echo "‚ùå ERROR: BUCKET_NAME is empty!"
          echo "EB_S3_BUCKET secret value: '${{ secrets.EB_S3_BUCKET }}'"
          exit 1
        fi
        
        aws elasticbeanstalk create-application-version \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --version-label "$VERSION_LABEL" \
          --source-bundle "S3Bucket=${BUCKET_NAME},S3Key=${S3_KEY}" \
          --description "Deployment from GitHub Actions - Commit: ${{ github.sha }}" \
          --region ${{ env.AWS_REGION }}
        
        echo "‚úÖ Application version created successfully"

    - name: Deploy to Elastic Beanstalk
      run: |
        aws elasticbeanstalk update-environment \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --environment-name ${{ steps.set-env.outputs.env_name }} \
          --version-label v-${{ steps.timestamp.outputs.timestamp }}-${{ github.run_number }}

    - name: Wait for environment to be ready
      run: |
        echo "Waiting for environment to be ready..."
        aws elasticbeanstalk wait environment-updated \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --environment-name ${{ steps.set-env.outputs.env_name }}

    - name: Get environment URL
      id: get-url
      run: |
        URL=$(aws elasticbeanstalk describe-environments \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --environment-names ${{ steps.set-env.outputs.env_name }} \
          --query "Environments[0].CNAME" \
          --output text)
        echo "url=http://${URL}" >> $GITHUB_OUTPUT
        echo "Environment URL: http://${URL}"

    - name: Check environment health
      run: |
        echo "Checking environment health status..."
        aws elasticbeanstalk describe-environment-health \
          --environment-name ${{ steps.set-env.outputs.env_name }} \
          --attribute-names All \
          --region ${{ env.AWS_REGION }} || echo "Could not get health status"

    - name: Health check
      continue-on-error: true
      run: |
        echo "Waiting for application to be ready..."
        sleep 60
        
        echo "Testing health endpoint..."
        for i in {1..5}; do
          echo "Attempt $i of 5..."
          if curl -f -m 30 ${{ steps.get-url.outputs.url }}/health; then
            echo "‚úÖ Health check passed!"
            exit 0
          fi
          echo "Health check failed, retrying in 30 seconds..."
          sleep 30
        done
        
        echo "‚ö†Ô∏è Health check failed after 5 attempts"
        echo "Note: This may be normal if the environment is still starting up"
        echo "Check the EB console for detailed logs: https://console.aws.amazon.com/elasticbeanstalk"

    - name: Deployment summary
      run: |
        echo "üöÄ Deployment successful!"
        echo "üì¶ Version: v-${{ steps.timestamp.outputs.timestamp }}-${{ github.run_number }}"
        echo "üåê URL: ${{ steps.get-url.outputs.url }}"
        echo "üîó Environment: ${{ steps.set-env.outputs.env_name }}"
        echo "üìä Health Check: ‚úÖ Passed"

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "‚úÖ Deployment succeeded"
        else
          echo "‚ùå Deployment failed"
        fi

  verify-mongodb:
    needs: deploy
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    steps:
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Install MongoDB client
      run: |
        pip install pymongo motor

    - name: Verify MongoDB connection
      run: |
        python -c "
        import asyncio
        from motor.motor_asyncio import AsyncIOMotorClient
        
        async def check_mongo():
            try:
                client = AsyncIOMotorClient('${{ secrets.MONGO_URI }}')
                await client.admin.command('ping')
                print('‚úÖ MongoDB connection successful')
                
                # List databases
                dbs = await client.list_database_names()
                print(f'üìä Available databases: {dbs}')
                
                # Check pickoo database
                db = client.pickoo
                collections = await db.list_collection_names()
                print(f'üìö Collections in pickoo: {collections}')
                
                # Verify collections exist
                required = ['users', 'transactions']
                for coll in required:
                    if coll in collections:
                        count = await db[coll].count_documents({})
                        print(f'‚úÖ Collection {coll}: {count} documents')
                    else:
                        print(f'‚ö†Ô∏è Collection {coll}: Not found')
                
                client.close()
            except Exception as e:
                print(f'‚ùå MongoDB verification failed: {e}')
                exit(1)
        
        asyncio.run(check_mongo())
        "

    - name: MongoDB status summary
      run: |
        echo "üóÑÔ∏è MongoDB verification completed"
        echo "‚úÖ Database connection: Active"
        echo "‚úÖ Collections: Verified"
